import { db, SyncItem } from '../db/db';
import api from './api';


class SyncService {
    private isOnline: boolean = navigator.onLine;

    constructor() {
        window.addEventListener('online', () => {
            this.isOnline = true;
            this.processQueue();
            console.log('Online - Processing Queue');
        });
        window.addEventListener('offline', () => {
            this.isOnline = false;
            console.log('Offline - Queue Paused');
        });
    }

    public getOnlineStatus(): boolean {
        return this.isOnline;
    }

    async addToQueue(action: SyncItem['action'], payload: any) {
        await db.syncQueue.add({
            action,
            payload,
            status: 'PENDING',
            createdAt: Date.now()
        });
        // Try to process immediately if online
        if (this.isOnline) {
            this.processQueue();
        }
    }

    async processQueue() {
        if (!this.isOnline) return;

        const pendingItems = await db.syncQueue
            .where('status')
            .equals('PENDING')
            .sortBy('createdAt');

        if (pendingItems.length === 0) return;

        // Use a simple banner or toast (if not inside React component) can be tricky.
        // For now we just process.

        for (const item of pendingItems) {
            try {
                await this.executeItem(item);
                await db.syncQueue.delete(item.id!);
            } catch (error) {
                console.error(`Sync failed for item ${item.id}`, error);
                await db.syncQueue.update(item.id!, {
                    status: 'ERROR',
                    error: JSON.stringify(error)
                });
            }
        }
    }

    private async executeItem(item: SyncItem) {
        switch (item.action) {
            case 'CREATE_FEUILLE':
                // Remove temporary ID if handled by server or keep mapping
                // const { id, ...data } = item.payload; // Remove local ID if needed?
                // actually we send the whole payload, backend should handle ID.
                // But usually we remove the UUID generated by client.
                const { id: _tempId, ...payloadWithoutId } = item.payload;
                await api.post('/feuilles', payloadWithoutId);
                break;
            case 'UPDATE_FEUILLE':
                await api.put(`/feuilles/${item.payload.id}`, item.payload.data);
                break;
            case 'DELETE_FEUILLE':
                await api.delete(`/feuilles/${item.payload.id}`);
                break;
        }
    }

    // Helper to pull data for offline cache
    async syncReferenceData() {
        if (!this.isOnline) return;
        try {
            const [monteurs, chantiers] = await Promise.all([
                api.get('/monteurs'),
                api.get('/chantiers')
            ]);

            await db.transaction('rw', db.monteurs, db.chantiers, async () => {
                await db.monteurs.clear();
                await db.monteurs.bulkAdd(monteurs.data.data || monteurs.data);

                await db.chantiers.clear();
                await db.chantiers.bulkAdd(chantiers.data.data || chantiers.data);
            });
            console.log('Reference data synced');
        } catch (error) {
            console.error('Failed to sync reference data', error);
        }
    }
}

export const syncService = new SyncService();
